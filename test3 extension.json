{"README.md":"\n> Open this page at [https://chenq86.github.io/test2-extension/](https://chenq86.github.io/test2-extension/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/chenq86/test2-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/chenq86/test2-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/chenq86/test2-extension** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/chenq86/test2-extension/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://chenq86.github.io/test2-extension/](https://chenq86.github.io/test2-extension/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/chenq86/test2-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/chenq86/test2-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/chenq86/test2-extension** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/chenq86/test2-extension/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://chenq86.github.io/test2-extension/](https://chenq86.github.io/test2-extension/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/chenq86/test2-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/chenq86/test2-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/chenq86/test2-extension** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/chenq86/test2-extension/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://chenq86.github.io/test3-extension/](https://chenq86.github.io/test3-extension/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/chenq86/test3-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/chenq86/test3-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/chenq86/test3-extension** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/chenq86/test3-extension/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"/>","main.ts":"enum PingUnit {\n    //% block=\"微秒\"\n    MicroSeconds,\n    //% block=\"厘米\"\n    Centimeters,\n    //% block=\"英寸\"\n    Inches\n}\n\nenum TMP36Type {\n    //% block=\"(℃)\" enumval=0\n    TMP36_temperature_C,\n\n    //% block=\"(℉)\" enumval=1\n    TMP36_temperature_F,\n}\n\nenum RGB {\n    //% block=\"红\"\n    RED,\n    //% block=\"绿\"\n    GREEN,\n    //% block=\"蓝\"\n    BLUE,\n    //% block=\"全部\"\n    CLEAR\n}\n\n\nenum NeoPixelColors {\n    //% block=红\n    Red = 0xFF0000,\n    //% block=橙\n    Orange = 0xFFA500,\n    //% block=黄\n    Yellow = 0xFFFF00,\n    //% block=绿\n    Green = 0x00FF00,\n    //% block=蓝\n    Blue = 0x0000FF,\n    //% block=靛蓝\n    Indigo = 0x4b0082,\n    //% block=紫罗兰\n    Violet = 0x8a2be2,\n    //% block=紫\n    Purple = 0xFF00FF,\n    //% block=白\n    White = 0xFFFFFF,\n    //% block=黑\n    Black = 0x000000\n}\nenum NeoPixelMode {\n    //% block=\"RGB (GRB 格式)\"\n    RGB = 1,\n    //% block=\"RGB+W\"\n    RGBW = 2,\n    //% block=\"RGB (RGB 格式)\"\n    RGB_RGB = 3\n}\n\n//% color=\"#eb834b\" icon=\"\\uf085\" block=\"IC:bit\"\nnamespace ICbit {\n\n    export enum DHT11_state {\n        //% block=\"温度(℃)\" enumval=0\n        DHT11_temperature_C,\n\n        //% block=\"湿度(0~100)\" enumval=1\n        DHT11_humidity,\n    }\n\n    export enum Distance_Unit_List {\n        //% block=\"厘米\" \n        Distance_Unit_cm,\n\n        //% block=\"英寸\"\n        Distance_Unit_inch,\n    }\n\n\n    //% blockId=\"readsoilmoisture\" block=\"土壤湿度传感器 %soilhumiditypin\"\n    //% subcategory=传感器\n    export function ReadSoilHumidity(soilmoisturepin: AnalogPin): number {\n        let voltage = 0;\n        let soilmoisture = 0;\n        voltage = pins.map(\n            pins.analogReadPin(soilmoisturepin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        soilmoisture = voltage;\n        return Math.round(soilmoisture);\n    }\n\n    //% blockId=\"readlightintensity\" block=\"光线传感器 %lightintensitypin\"\n    //% subcategory=传感器\n    export function ReadLightIntensity(lightintensitypin: AnalogPin): number {\n        let voltage2 = 0;\n        let lightintensity = 0;\n        voltage2 = pins.map(\n            pins.analogReadPin(lightintensitypin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        lightintensity = voltage2;\n        return Math.round(1023 - lightintensity);\n    }\n\n    //% blockId=\"readnoise\" block=\"声音传感器 %noisepin\"\n    //% subcategory=传感器\n    export function ReadNoise(noisepin: AnalogPin): number {\n        let level = 0\n        let voltage3 = 0\n        let noise = 0\n        let h = 0\n        let l = 0\n        let sumh = 0\n        let suml = 0\n        pins.digitalWritePin(DigitalPin.P0, 0)\n        for (let i = 0; i < 1000; i++) {\n            level = level + pins.analogReadPin(noisepin)\n        }\n        level = level / 1000\n        for (let j = 0; j < 1000; j++) {\n            voltage3 = pins.analogReadPin(noisepin)\n            if (voltage3 >= level) {\n                h += 1\n                sumh = sumh + voltage3\n            } else {\n                l += 1\n                suml = suml + voltage3\n            }\n        }\n        if (h == 0) {\n            sumh = level\n        } else {\n            sumh = sumh / h\n        }\n        if (l == 0) {\n            suml = level\n        } else {\n            suml = suml / l\n        }\n        noise = sumh - suml\n        if (noise <= 4) {\n            noise = pins.map(\n                noise,\n                0,\n                4,\n                30,\n                50\n            )\n        } else if (noise <= 8) {\n            noise = pins.map(\n                noise,\n                4,\n                8,\n                50,\n                55\n            )\n        } else if (noise <= 14) {\n            noise = pins.map(\n                noise,\n                9,\n                14,\n                55,\n                60\n            )\n        } else if (noise <= 32) {\n            noise = pins.map(\n                noise,\n                15,\n                32,\n                60,\n                70\n            )\n        } else if (noise <= 60) {\n            noise = pins.map(\n                noise,\n                33,\n                60,\n                70,\n                75\n            )\n        } else if (noise <= 100) {\n            noise = pins.map(\n                noise,\n                61,\n                100,\n                75,\n                80\n            )\n        } else if (noise <= 150) {\n            noise = pins.map(\n                noise,\n                101,\n                150,\n                80,\n                85\n            )\n        } else if (noise <= 231) {\n            noise = pins.map(\n                noise,\n                151,\n                231,\n                85,\n                90\n            )\n        } else {\n            noise = pins.map(\n                noise,\n                231,\n                1023,\n                90,\n                120\n            )\n        }\n        noise = Math.round(noise)\n        return Math.round(noise)\n    }\n\n    /**\n    * toggle fans\n    */\n    //% blockId=fans block=\"电机风扇 %pin 切换至 $fanstate || 速度 %speed\"\n    //% fanstate.shadow=\"toggleOnOff\"\n    //% speed.min=0 speed.max=1023\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function motorFan(pin: AnalogPin, fanstate: boolean, speed: number = 1023): void {\n        if (fanstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(speed, 0, 1023, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 0)\n            speed = 0\n        }\n    }\n\n    /**\n    * get Ultrasonic distance\n    */\n    //% blockId=sonarbit\n    //% distance_unit.fieldEditor=\"gridpicker\"\n    //% distance_unit.fieldOptions.columns=2\n    //% subcategory=传感器\n    //% blockId=sonar_ping block=\"ping trig %trig echo %echo 单位 %unit\"\n    export function ping(trig: DigitalPin, echo: DigitalPin, unit: PingUnit, maxCmDistance = 500): number {\n        // send pulse\n        pins.setPull(trig, PinPullMode.PullNone);\n        pins.digitalWritePin(trig, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(trig, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trig, 0);\n\n        // read pulse\n        const d = pins.pulseIn(echo, PulseValue.High, maxCmDistance * 58);\n\n        switch (unit) {\n            case PingUnit.Centimeters: return Math.idiv(d, 58);\n            case PingUnit.Inches: return Math.idiv(d, 148);\n            default: return d;\n        }\n    }\n\n    /**\n    * toggle led\n    */\n    //% blockId=LEDR block=\"红色 LED %pin 切换到 $ledstate || 亮度 %brightness\"\n    //% brightness.min=0 brightness.max=1023\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function ledRBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 1023)\n            brightness = 1023\n        }\n    }\n\n    /**\n    * toggle led\n    */\n    //% blockId=LEDG block=\"绿色 LED %pin 切换到 $ledstate || 亮度 %brightness\"\n    //% brightness.min=0 brightness.max=1023\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function ledGBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 1023)\n            brightness = 1023\n        }\n    }\n\n    /**\n    * toggle led\n    */\n    //% blockId=LEDB block=\"蓝色 LED %pin 切换到 $ledstate || 亮度 %brightness\"\n    //% brightness.min=0 brightness.max=1023\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function ledBBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 1023)\n            brightness = 1023\n        }\n    }\n\n    /**\n    * toggle led\n    */\n    //% blockId=LEDY block=\"黄色 LED %pin 切换到 $ledstate || 亮度 %brightness\"\n    //% brightness.min=0 brightness.max=1023\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function ledYBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 1023)\n            brightness = 1023\n        }\n    }\n\n    const PCA9685_ADD = 0x40\n    const MODE1 = 0x00\n    const LED0_ON_L = 0x06\n    const PRESCALE = 0xFE\n\n    let initialized = false\n\n    export enum enPos {\n        //% blockId=\"forward\" block=\"前进\"\n        forward = 1,\n        //% blockId=\"stop\" block=\"后退\"\n        stop = 2\n    }\n\n    export enum enServo {\n        S1 = 0,\n        S2,\n        S3,\n        S4\n    }\n\n    export enum enMotors {\n        M1 = 8,\n        M2 = 10,\n        M3 = 12,\n        M4 = 14\n    }\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADD, MODE1, 0x00)\n        setFreq(50);\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADD, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADD, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        if (!initialized) {\n            initPCA9685();\n        }\n        let buf2 = pins.createBuffer(5);\n        buf2[0] = LED0_ON_L + 4 * channel;\n        buf2[1] = on & 0xff;\n        buf2[2] = (on >> 8) & 0xff;\n        buf2[3] = off & 0xff;\n        buf2[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADD, buf2);\n    }\n\n    //% blockId=SuperBit_Servo4 block=\"Geek舵机| %num|角度 %value\"\n    //% num.min=1 num.max=4 value.min=0 value.max=300\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=20\n    //% subcategory=执行器\n    export function Servo4(num: enServo, value: number): void {\n\n        // 50hz: 20,000 us\n        let us = (value * 1800 * 0.6 / 180 + 600); // 0.6 ~ 2.4\n        let pwm = us * 4096 / 20000;\n        setPwm(num, 0, pwm);\n\n    }\n\n    //% blockId=SuperBit_MotorRun block=\"电机|%index|速度(-255~255) %speed\"\n    //% speed.min=-255 speed.max=255\n    //% subcategory=执行器\n    export function MotorRun(index: enMotors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n\n        let a = index\n        let b = index + 1\n\n        if (a > 10) {\n            if (speed >= 0) {\n                setPwm(a, 0, speed)\n                setPwm(b, 0, 0)\n            } else {\n                setPwm(a, 0, 0)\n                setPwm(b, 0, -speed)\n            }\n        }\n        else {\n            if (speed >= 0) {\n                setPwm(b, 0, speed)\n                setPwm(a, 0, 0)\n            } else {\n                setPwm(b, 0, 0)\n                setPwm(a, 0, -speed)\n            }\n        }\n    }\n\n    //% blockId=\"elecmagnet\" block=\"电磁铁 %pin 切换至 %magState || 磁力 %force\"\n    //% magState.shadow=\"toggleOnOff\"\n    //% force.min=0 force.max=1023\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function elecmagnet(pin: AnalogPin, magState: boolean, force: number = 1023): void {\n\n        if (magState) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(force, 0, 1023, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 0)\n            force = 0\n        }\n    }\n\n    //% blockId=\"laser_controller\" block=\"激光 %pin 切换至 %laserState || 激光 %intensity\"\n    //% laserState.shadow=\"toggleOnOff\"\n    //% intensity.min=0 intensity.max=1023\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function laserController(pin: AnalogPin, laserState: boolean, intensity: number = 1023): void {\n\n        if (laserState) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(intensity, 0, 1023, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 0)\n            intensity = 0\n        }\n    }\n\n    //% blockId=\"octopus_ReadWaterLevel\" block=\"水位传感器 %waterlevelpin\"\n    //% subcategory=传感器\n    export function ReadWaterLevel(waterlevelpin: AnalogPin): number {\n        let voltage = 0;\n        let waterLevel = 0;\n        voltage = pins.map(\n            pins.analogReadPin(waterlevelpin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        waterLevel = voltage;\n        return Math.round(waterLevel);\n    }\n\n    //% blockId=\"ReadGasConcentration\" block=\"可燃气体传感器 %gasconcentrationpin\"\n    //% subcategory=传感器\n    export function ReadGasConcentration(gasconcentrationpin: AnalogPin): number {\n        let voltage = 0;\n        let gasConcentration = 0;\n        voltage = pins.map(\n            pins.analogReadPin(gasconcentrationpin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        gasConcentration = voltage;\n        return Math.round(gasConcentration);\n    }\n\n    //% blockId=\"Readflame\" block=\"火焰传感器 %flamepin\"\n    //% subcategory=传感器\n    export function Readflame(flamepin: AnalogPin): number {\n        let voltage = 0;\n        let flame = 0;\n        voltage = pins.map(\n            pins.analogReadPin(flamepin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        flame = voltage;\n        return Math.round(flame);\n    }\n\n    //% blockId=\"ReadGrayLevel\" block=\"灰度传感器 %graylevelpin\"\n    //% subcategory=传感器\n    export function ReadGrayLevel(graylevelpin: AnalogPin): number {\n        let voltage = 0;\n        let grayLevel = 0;\n        voltage = pins.map(\n            pins.analogReadPin(graylevelpin),\n            0,\n            1023,\n            80,\n            1023\n        );\n        grayLevel = voltage;\n        return Math.round(grayLevel);\n    }\n\n    //% blockId=\"readWaterTemp\" block=\"防水温度传感器 %waterproofpin\"\n    //% subcategory=传感器\n    export function readWaterTemp(waterproofpin: AnalogPin): number {\n        let voltage2 = 0;\n        let waterProofTemp = 0;\n        voltage2 = pins.map(\n            pins.analogReadPin(waterproofpin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        waterProofTemp = voltage2;\n        return Math.round(1023 - waterProofTemp);\n    }\n\n    //% blockId=potentiometerRead\n    //% block=\"电位器 %pin\"\n    //% subcategory=传感器\n    export function potentiometerRead(pin: AnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n    //% blockId=buttonState\n    //% block=\"按钮传感器 %pin\"\n    //% subcategory=传感器\n    export function buttonState(pin: DigitalPin): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    //% blockId=closeState\n    //% block=\"近距离光电传感器 %pin\"\n    //% subcategory=传感器\n    export function closeState(pin: DigitalPin): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    //% blockId=farState\n    //% block=\"远距离光电传感器 %pin\"\n    //% subcategory=传感器\n    export function farState(pin: DigitalPin): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    //% blockId=hState\n    //% block=\"霍尔传感器 %pin\"\n    //% subcategory=传感器\n    export function hState(pin: AnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n    enum LCS_Constants {\n        // Constants\n        ADDRESS = 0x29,\n        ID = 0x12, // Register should be equal to 0x44 for the TCS34721 or TCS34725, or 0x4D for the TCS34723 or TCS34727.\n\n        COMMAND_BIT = 0x80,\n\n        ENABLE = 0x00,\n        ENABLE_AIEN = 0x10, // RGBC Interrupt Enable\n        ENABLE_WEN = 0x08, // Wait enable - Writing 1 activates the wait timer\n        ENABLE_AEN = 0x02, // RGBC Enable - Writing 1 actives the ADC, 0 disables it\n        ENABLE_PON = 0x01, // Power on - Writing 1 activates the internal oscillator, 0 disables it\n        ATIME = 0x01, // Integration time\n        WTIME = 0x03, // Wait time (if ENABLE_WEN is asserted)\n        AILTL = 0x04, // Clear channel lower interrupt threshold\n        AILTH = 0x05,\n        AIHTL = 0x06, // Clear channel upper interrupt threshold\n        AIHTH = 0x07,\n        PERS = 0x0C, // Persistence register - basic SW filtering mechanism for interrupts\n        PERS_NONE = 0x00, // Every RGBC cycle generates an interrupt\n        PERS_1_CYCLE = 0x01, // 1 clean channel value outside threshold range generates an interrupt\n        PERS_2_CYCLE = 0x02, // 2 clean channel values outside threshold range generates an interrupt\n        PERS_3_CYCLE = 0x03, // 3 clean channel values outside threshold range generates an interrupt\n        PERS_5_CYCLE = 0x04, // 5 clean channel values outside threshold range generates an interrupt\n        PERS_10_CYCLE = 0x05, // 10 clean channel values outside threshold range generates an interrupt\n        PERS_15_CYCLE = 0x06, // 15 clean channel values outside threshold range generates an interrupt\n        PERS_20_CYCLE = 0x07, // 20 clean channel values outside threshold range generates an interrupt\n        PERS_25_CYCLE = 0x08, // 25 clean channel values outside threshold range generates an interrupt\n        PERS_30_CYCLE = 0x09, // 30 clean channel values outside threshold range generates an interrupt\n        PERS_35_CYCLE = 0x0A, // 35 clean channel values outside threshold range generates an interrupt\n        PERS_40_CYCLE = 0x0B, // 40 clean channel values outside threshold range generates an interrupt\n        PERS_45_CYCLE = 0x0C, // 45 clean channel values outside threshold range generates an interrupt\n        PERS_50_CYCLE = 0x0D, // 50 clean channel values outside threshold range generates an interrupt\n        PERS_55_CYCLE = 0x0E, // 55 clean channel values outside threshold range generates an interrupt\n        PERS_60_CYCLE = 0x0F, // 60 clean channel values outside threshold range generates an interrupt\n        CONFIG = 0x0D,\n        CONFIG_WLONG = 0x02, // Choose between short and long (12x) wait times via WTIME\n        CONTROL = 0x0F, // Set the gain level for the sensor\n        STATUS = 0x13,\n        STATUS_AINT = 0x10, // RGBC Clean channel interrupt\n        STATUS_AVALID = 0x01, // Indicates that the RGBC channels have completed an integration cycle\n\n        CDATAL = 0x14, // Clear channel data\n        CDATAH = 0x15,\n        RDATAL = 0x16, // Red channel data\n        RDATAH = 0x17,\n        GDATAL = 0x18, // Green channel data\n        GDATAH = 0x19,\n        BDATAL = 0x1A, // Blue channel data\n        BDATAH = 0x1B,\n\n        GAIN_1X = 0x00, //  1x gain\n        GAIN_4X = 0x01, //  4x gain\n        GAIN_16X = 0x02, // 16x gain\n        GAIN_60X = 0x03  // 60x gain\n    }\n\n    let LCS_integration_time_val = 0\n\n    // I2C functions\n\n    function I2C_WriteReg8(addr: number, reg: number, val: number) {\n        let buf = pins.createBuffer(2)\n        buf.setNumber(NumberFormat.UInt8BE, 0, reg)\n        buf.setNumber(NumberFormat.UInt8BE, 1, val)\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function I2C_ReadReg8(addr: number, reg: number): number {\n        let buf = pins.createBuffer(1)\n        buf.setNumber(NumberFormat.UInt8BE, 0, reg)\n        pins.i2cWriteBuffer(addr, buf)\n        buf = pins.i2cReadBuffer(addr, 1)\n        return buf.getNumber(NumberFormat.UInt8BE, 0);\n    }\n\n    function I2C_ReadReg16(addr: number, reg: number): number {\n        let buf = pins.createBuffer(1)\n        buf.setNumber(NumberFormat.UInt8BE, 0, reg)\n        pins.i2cWriteBuffer(addr, buf)\n        buf = pins.i2cReadBuffer(addr, 2)\n        // Little endian\n        return ((buf.getNumber(NumberFormat.UInt8BE, 1) << 8) | buf.getNumber(NumberFormat.UInt8BE, 0));\n    }\n\n    //% blockId=\"initialize_sensor\" block=\"初始化颜色传感器\"\n    //% subcategory=\"传感器\"\n    export function LCS_initialize() {\n        // Make sure we're connected to the right sensor.\n        let chip_id = I2C_ReadReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ID))\n\n        if (chip_id != 0x44) {\n            return // Incorrect chip ID\n        }\n\n        // Set default integration time and gain.\n        LCS_set_integration_time(0.0048)\n        LCS_set_gain(LCS_Constants.GAIN_16X)\n\n        // Enable the device (by default, the device is in power down mode on bootup).\n        LCS_enable()\n    }\n\n    function LCS_enable() {\n        // Set the power and enable bits.\n        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ENABLE), LCS_Constants.ENABLE_PON)\n        basic.pause(10) // not sure if this is right    time.sleep(0.01) // FIXME delay for 10ms\n\n        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ENABLE), (LCS_Constants.ENABLE_PON | LCS_Constants.ENABLE_AEN))\n    }\n\n    function LCS_set_integration_time(time: number) {\n        let val = 0x100 - (time / 0.0024) // FIXME was cast to int type\n        if (val > 255) {\n            val = 255\n        } else if (val < 0) {\n            val = 0\n        }\n        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ATIME), val)\n        LCS_integration_time_val = val\n    }\n\n    function LCS_set_gain(gain: number) {\n        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CONTROL), gain)\n    }\n\n    function LCS_set_led_state(state: boolean) {\n        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.PERS), LCS_Constants.PERS_NONE)\n        let val = I2C_ReadReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ENABLE))\n        if (state) {\n            val |= LCS_Constants.ENABLE_AIEN\n        } else {\n            val &= ~LCS_Constants.ENABLE_AIEN\n        }\n        I2C_WriteReg8(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.ENABLE), val)\n\n        basic.pause(2 * (256 - LCS_integration_time_val) * 2.4) // delay for long enough for there to be new (post-change) complete values available\n    }\n\n    //% blockId=\"octopus_getSensorData\" block=\"读取颜色值 %colorId\"\n    //% subcategory=\"传感器\"\n    export function getColorData(color: RGB): number {\n        basic.pause((256 - LCS_integration_time_val) * 2.4);\n        let sum = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CDATAL));\n        let vue = 0;\n        switch (color) {\n            case RGB.RED:\n                vue = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.RDATAL));\n                break;\n            case RGB.GREEN:\n                vue = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.GDATAL));\n                break;\n            case RGB.BLUE:\n                vue = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.BDATAL));\n                break;\n            case RGB.CLEAR:\n                return sum;\n                break;\n\n        }\n        vue = Math.floor(vue / sum * 255);\n\n        serial.writeLine(\"val: \" + vue);\n        return vue;\n    }\n\n\n    function LCS_get_raw_data(delay: boolean = false): number[] {\n        if (delay) {\n            // Delay for the integration time to allow reading immediately after the previous read.\n            basic.pause((256 - LCS_integration_time_val) * 2.4)\n        }\n\n        let div = (256 - LCS_integration_time_val) * 1024\n        let rgbc = [0, 0, 0, 0]\n        rgbc[0] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.RDATAL)) / div\n        rgbc[1] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.GDATAL)) / div\n        rgbc[2] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.BDATAL)) / div\n        rgbc[3] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CDATAL)) / div\n        if (rgbc[0] > 1) {\n            rgbc[0] = 1\n        }\n        if (rgbc[1] > 1) {\n            rgbc[1] = 1\n        }\n        if (rgbc[2] > 1) {\n            rgbc[2] = 1\n        }\n        if (rgbc[3] > 1) {\n            rgbc[3] = 1\n        }\n        return rgbc\n    }\n\n    let font: number[] = [];\n    font[0] = 0x0022d422;\n    font[1] = 0x0022d422;\n    font[2] = 0x0022d422;\n    font[3] = 0x0022d422;\n    font[4] = 0x0022d422;\n    font[5] = 0x0022d422;\n    font[6] = 0x0022d422;\n    font[7] = 0x0022d422;\n    font[8] = 0x0022d422;\n    font[9] = 0x0022d422;\n    font[10] = 0x0022d422;\n    font[11] = 0x0022d422;\n    font[12] = 0x0022d422;\n    font[13] = 0x0022d422;\n    font[14] = 0x0022d422;\n    font[15] = 0x0022d422;\n    font[16] = 0x0022d422;\n    font[17] = 0x0022d422;\n    font[18] = 0x0022d422;\n    font[19] = 0x0022d422;\n    font[20] = 0x0022d422;\n    font[21] = 0x0022d422;\n    font[22] = 0x0022d422;\n    font[23] = 0x0022d422;\n    font[24] = 0x0022d422;\n    font[25] = 0x0022d422;\n    font[26] = 0x0022d422;\n    font[27] = 0x0022d422;\n    font[28] = 0x0022d422;\n    font[29] = 0x0022d422;\n    font[30] = 0x0022d422;\n    font[31] = 0x0022d422;\n    font[32] = 0x00000000;\n    font[33] = 0x000002e0;\n    font[34] = 0x00018060;\n    font[35] = 0x00afabea;\n    font[36] = 0x00aed6ea;\n    font[37] = 0x01991133;\n    font[38] = 0x010556aa;\n    font[39] = 0x00000060;\n    font[40] = 0x000045c0;\n    font[41] = 0x00003a20;\n    font[42] = 0x00051140;\n    font[43] = 0x00023880;\n    font[44] = 0x00002200;\n    font[45] = 0x00021080;\n    font[46] = 0x00000100;\n    font[47] = 0x00111110;\n    font[48] = 0x0007462e;\n    font[49] = 0x00087e40;\n    font[50] = 0x000956b9;\n    font[51] = 0x0005d629;\n    font[52] = 0x008fa54c;\n    font[53] = 0x009ad6b7;\n    font[54] = 0x008ada88;\n    font[55] = 0x00119531;\n    font[56] = 0x00aad6aa;\n    font[57] = 0x0022b6a2;\n    font[58] = 0x00000140;\n    font[59] = 0x00002a00;\n    font[60] = 0x0008a880;\n    font[61] = 0x00052940;\n    font[62] = 0x00022a20;\n    font[63] = 0x0022d422;\n    font[64] = 0x00e4d62e;\n    font[65] = 0x000f14be;\n    font[66] = 0x000556bf;\n    font[67] = 0x0008c62e;\n    font[68] = 0x0007463f;\n    font[69] = 0x0008d6bf;\n    font[70] = 0x000094bf;\n    font[71] = 0x00cac62e;\n    font[72] = 0x000f909f;\n    font[73] = 0x000047f1;\n    font[74] = 0x0017c629;\n    font[75] = 0x0008a89f;\n    font[76] = 0x0008421f;\n    font[77] = 0x01f1105f;\n    font[78] = 0x01f4105f;\n    font[79] = 0x0007462e;\n    font[80] = 0x000114bf;\n    font[81] = 0x000b6526;\n    font[82] = 0x010514bf;\n    font[83] = 0x0004d6b2;\n    font[84] = 0x0010fc21;\n    font[85] = 0x0007c20f;\n    font[86] = 0x00744107;\n    font[87] = 0x01f4111f;\n    font[88] = 0x000d909b;\n    font[89] = 0x00117041;\n    font[90] = 0x0008ceb9;\n    font[91] = 0x0008c7e0;\n    font[92] = 0x01041041;\n    font[93] = 0x000fc620;\n    font[94] = 0x00010440;\n    font[95] = 0x01084210;\n    font[96] = 0x00000820;\n    font[97] = 0x010f4a4c;\n    font[98] = 0x0004529f;\n    font[99] = 0x00094a4c;\n    font[100] = 0x000fd288;\n    font[101] = 0x000956ae;\n    font[102] = 0x000097c4;\n    font[103] = 0x0007d6a2;\n    font[104] = 0x000c109f;\n    font[105] = 0x000003a0;\n    font[106] = 0x0006c200;\n    font[107] = 0x0008289f;\n    font[108] = 0x000841e0;\n    font[109] = 0x01e1105e;\n    font[110] = 0x000e085e;\n    font[111] = 0x00064a4c;\n    font[112] = 0x0002295e;\n    font[113] = 0x000f2944;\n    font[114] = 0x0001085c;\n    font[115] = 0x00012a90;\n    font[116] = 0x010a51e0;\n    font[117] = 0x010f420e;\n    font[118] = 0x00644106;\n    font[119] = 0x01e8221e;\n    font[120] = 0x00093192;\n    font[121] = 0x00222292;\n    font[122] = 0x00095b52;\n    font[123] = 0x0008fc80;\n    font[124] = 0x000003e0;\n    font[125] = 0x000013f1;\n    font[126] = 0x00841080;\n    font[127] = 0x0022d422;\n\n    let _I2CAddr = 0;\n    let _screen = pins.createBuffer(1025);\n    let _buf2 = pins.createBuffer(2);\n    let _buf3 = pins.createBuffer(3);\n    let _buf4 = pins.createBuffer(4);\n    let _ZOOM = 1;\n\n    function cmd1(d: number) {\n        let n = d % 256;\n        pins.i2cWriteNumber(_I2CAddr, n, NumberFormat.UInt16BE);\n    }\n\n    function cmd2(d1: number, d2: number) {\n        _buf3[0] = 0;\n        _buf3[1] = d1;\n        _buf3[2] = d2;\n        pins.i2cWriteBuffer(_I2CAddr, _buf3);\n    }\n\n    function cmd3(d1: number, d2: number, d3: number) {\n        _buf4[0] = 0;\n        _buf4[1] = d1;\n        _buf4[2] = d2;\n        _buf4[3] = d3;\n        pins.i2cWriteBuffer(_I2CAddr, _buf4);\n    }\n\n    function set_pos(col: number = 0, page: number = 0) {\n        cmd1(0xb0 | page) // page number\n        let c = col * (_ZOOM + 1)\n        cmd1(0x00 | (c % 16)) // lower start column address\n        cmd1(0x10 | (c >> 4)) // upper start column address    \n    }\n\n    // clear bit\n    function clrbit(d: number, b: number): number {\n        if (d & (1 << b))\n            d -= (1 << b)\n        return d\n    }\n\n    /**\n     * set pixel in OLED\n     * @param x is X alis, eg: 0\n     * @param y is Y alis, eg: 0\n     * @param color is dot color, eg: 1\n     */\n    //% blockId=\"OLED12864_I2C_PIXEL\" block=\"设置 pixel 在 x %x|y %y|颜色 %color\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% weight=80 blockGap=10 color=#0855AA\n    export function pixel(x: number, y: number, color: number = 1) {\n        let page = y >> 3\n        let shift_page = y % 8\n        let ind = x * (_ZOOM + 1) + page * 128 + 1\n        let b = (color) ? (_screen[ind] | (1 << shift_page)) : clrbit(_screen[ind], shift_page)\n        _screen[ind] = b\n        set_pos(x, page)\n        if (_ZOOM) {\n            _screen[ind + 1] = b\n            _buf3[0] = 0x40\n            _buf3[1] = _buf3[2] = b\n            pins.i2cWriteBuffer(_I2CAddr, _buf3)\n        }\n        else {\n            _buf2[0] = 0x40\n            _buf2[1] = b\n            pins.i2cWriteBuffer(_I2CAddr, _buf2)\n        }\n    }\n\n    /**\n     * show text in OLED\n     * @param x is X alis, eg: 0\n     * @param y is Y alis, eg: 0\n     * @param s is the text will be show, eg: 'Hello!'\n     * @param color is string color, eg: 1\n     */\n    //% blockId=\"OLED12864_I2C_SHOWSTRING\" block=\"显示 string 在 x %x|y %y|文本 %s|颜色 %color\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% weight=80 blockGap=10 color=#0855AA\n    export function showString(x: number, y: number, s: string, color: number = 1) {\n        let col = 0\n        let p = 0\n        let ind = 0\n        for (let n = 0; n < s.length; n++) {\n            p = font[s.charCodeAt(n)]\n            for (let i = 0; i < 5; i++) {\n                col = 0\n                for (let j = 0; j < 5; j++) {\n                    if (p & (1 << (5 * i + j)))\n                        col |= (1 << (j + 1))\n                }\n                ind = (x + n) * 5 * (_ZOOM + 1) + y * 128 + i * (_ZOOM + 1) + 1\n                if (color == 0)\n                    col = 255 - col\n                _screen[ind] = col\n                if (_ZOOM)\n                    _screen[ind + 1] = col\n            }\n        }\n        set_pos(x * 5, y)\n        let ind0 = x * 5 * (_ZOOM + 1) + y * 128\n        let buf = _screen.slice(ind0, ind + 1)\n        buf[0] = 0x40\n        pins.i2cWriteBuffer(_I2CAddr, buf)\n    }\n\n    /**\n     * show a number in OLED\n     * @param x is X alis, eg: 0\n     * @param y is Y alis, eg: 0\n     * @param num is the number will be show, eg: 12\n     * @param color is number color, eg: 1\n     */\n    //% blockId=\"OLED12864_I2C_NUMBER\" block=\"显示 数字 在 x %x|y %y|数字 %num|颜色 %color\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% weight=80 blockGap=10 color=#0855AA\n    export function showNumber(x: number, y: number, num: number, color: number = 1) {\n        showString(x, y, num.toString(), color)\n    }\n\n    /**\n     * draw / redraw screen\n     */\n    //% blockId=\"OLED12864_I2C_DRAW\" block=\"画\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% weight=64 blockGap=10 color=#0855AA\n    export function draw() {\n        set_pos()\n        pins.i2cWriteBuffer(_I2CAddr, _screen)\n    }\n\n    /**\n     * clear screen\n     */\n    //% blockId=\"OLED12864_I2C_CLEAR\" block=\"清除\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% weight=63 blockGap=10 color=#0855AA\n    export function clear() {\n        _screen.fill(0)\n        _screen[0] = 0x40\n        draw()\n    }\n\n    /**\n     * OLED initialize\n     * @param addr is i2c addr, eg: 60\n     */\n    //% blockId=\"OLED12864_I2C_init\" block=\"初始化 OLED 地址为 %addr\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% weight=85 blockGap=10\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% blockGap=10  color=#0855AA\n    export function init(addr: number) {\n        _I2CAddr = addr;\n        cmd1(0xAE)       // SSD1306_DISPLAYOFF\n        cmd1(0xA4)       // SSD1306_DISPLAYALLON_RESUME\n        cmd2(0xD5, 0xF0) // SSD1306_SETDISPLAYCLOCKDIV\n        cmd2(0xA8, 0x3F) // SSD1306_SETMULTIPLEX\n        cmd2(0xD3, 0x00) // SSD1306_SETDISPLAYOFFSET\n        cmd1(0 | 0x0)    // line #SSD1306_SETSTARTLINE\n        cmd2(0x8D, 0x14) // SSD1306_CHARGEPUMP\n        cmd2(0x20, 0x00) // SSD1306_MEMORYMODE\n        cmd3(0x21, 0, 127) // SSD1306_COLUMNADDR\n        cmd3(0x22, 0, 63)  // SSD1306_PAGEADDR\n        cmd1(0xa0 | 0x1) // SSD1306_SEGREMAP\n        cmd1(0xc8)       // SSD1306_COMSCANDEC\n        cmd2(0xDA, 0x12) // SSD1306_SETCOMPINS\n        cmd2(0x81, 0xCF) // SSD1306_SETCONTRAST\n        cmd2(0xd9, 0xF1) // SSD1306_SETPRECHARGE\n        cmd2(0xDB, 0x40) // SSD1306_SETVCOMDETECT\n        cmd1(0xA6)       // SSD1306_NORMALDISPLAY\n        cmd2(0xD6, 1)    // zoom on\n        cmd1(0xAF)       // SSD1306_DISPLAYON\n        clear()\n        _ZOOM = 1\n    }\n\n    /**\n     * A NeoPixel strip\n     */\n    export class Strip {\n        buf: Buffer;\n        pin: DigitalPin;\n        // TODO: encode as bytes instead of 32bit\n        brightness: number;\n        start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _matrixWidth: number; // number of leds in a matrix - if any\n\n        /**\n         * Shows all LEDs to a given color (range 0-255 for r, g, b).\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_strip_color\" block=\"%strip|显示 颜色 %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        showColor(rgb: number) {\n            rgb = rgb >> 0;\n            this.setAllRGB(rgb);\n            this.show();\n        }\n\n        /**\n         * Shows a rainbow pattern on all LEDs.\n         * @param startHue the start hue value for the rainbow, eg: 1\n         * @param endHue the end hue value for the rainbow, eg: 360\n         */\n        //% blockId=\"neopixel_set_strip_rainbow\" block=\"%strip|显示 彩虹 从 %startHue|到 %endHue\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\" \n        //% color=#2699BF blockGap=10\n        showRainbow(startHue: number = 1, endHue: number = 360) {\n            if (this._length <= 0) return;\n\n            startHue = startHue >> 0;\n            endHue = endHue >> 0;\n            const saturation = 100;\n            const luminance = 50;\n            const steps = this._length;\n            const direction = HueInterpolationDirection.Clockwise;\n\n            //hue\n            const h1 = startHue;\n            const h2 = endHue;\n            const hDistCW = ((h2 + 360) - h1) % 360;\n            const hStepCW = Math.idiv((hDistCW * 100), steps);\n            const hDistCCW = ((h1 + 360) - h2) % 360;\n            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\n            let hStep: number;\n            if (direction === HueInterpolationDirection.Clockwise) {\n                hStep = hStepCW;\n            } else if (direction === HueInterpolationDirection.CounterClockwise) {\n                hStep = hStepCCW;\n            } else {\n                hStep = hDistCW < hDistCCW ? hStepCW : hStepCCW;\n            }\n            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n\n            //sat\n            const s1 = saturation;\n            const s2 = saturation;\n            const sDist = s2 - s1;\n            const sStep = Math.idiv(sDist, steps);\n            const s1_100 = s1 * 100;\n\n            //lum\n            const l1 = luminance;\n            const l2 = luminance;\n            const lDist = l2 - l1;\n            const lStep = Math.idiv(lDist, steps);\n            const l1_100 = l1 * 100\n\n            //interpolate\n            if (steps === 1) {\n                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\n            } else {\n                this.setPixelColor(0, hsl(startHue, saturation, luminance));\n                for (let i = 1; i < steps - 1; i++) {\n                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;\n                    const s = Math.idiv((s1_100 + i * sStep), 100);\n                    const l = Math.idiv((l1_100 + i * lStep), 100);\n                    this.setPixelColor(i, hsl(h, s, l));\n                }\n                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\n            }\n            this.show();\n        }\n\n        /**\n         * Displays a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, eg: 255\n         */\n        //% blockId=neopixel_show_bar_graph block=\"%strip|显示 柱状图 从 %value|到 %high\"\n        //% icon=\"\\uf080\"\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        showBarGraph(value: number, high: number): void {\n            if (high <= 0) {\n                this.clear();\n                this.setPixelColor(0, NeoPixelColors.Yellow);\n                this.show();\n                return;\n            }\n\n            value = Math.abs(value);\n            const n = this._length;\n            const n1 = n - 1;\n            let v = Math.idiv((value * n), high);\n            if (v == 0) {\n                this.setPixelColor(0, 0x666600);\n                for (let i = 1; i < n; ++i)\n                    this.setPixelColor(i, 0);\n            } else {\n                for (let i = 0; i < n; ++i) {\n                    if (i <= v) {\n                        const b = Math.idiv(i * 255, n1);\n                        this.setPixelColor(i, ICbit.rgb(b, 0, 255 - b));\n                    }\n                    else this.setPixelColor(i, 0);\n                }\n            }\n            this.show();\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b).\n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_pixel_color\" block=\"%strip|设置 pixel 颜色 在 %pixeloffset|到 %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        setPixelColor(pixeloffset: number, rgb: number): void {\n            this.setPixelRGB(pixeloffset >> 0, rgb >> 0);\n        }\n\n        /**\n         * Sets the number of pixels in a matrix shaped strip\n         * @param width number of pixels in a row\n         */\n        //% blockId=neopixel_set_matrix_width block=\"%strip|设置 矩阵 宽度 %width\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\" \n        //% color=#2699BF blockGap=10\n        setMatrixWidth(width: number) {\n            this._matrixWidth = Math.min(this._length, width >> 0);\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b) in a matrix shaped strip\n         * You need to call ``show`` to make the changes visible.\n         * @param x horizontal position\n         * @param y horizontal position\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_matrix_color\" block=\"%strip|设置 矩阵 颜色 在 x %x|y %y|到 %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        setMatrixColor(x: number, y: number, rgb: number) {\n            if (this._matrixWidth <= 0) return; // not a matrix, ignore\n            x = x >> 0;\n            y = y >> 0;\n            rgb = rgb >> 0;\n            const cols = Math.idiv(this._length, this._matrixWidth);\n            if (x < 0 || x >= this._matrixWidth || y < 0 || y >= cols) return;\n            let i = x + y * this._matrixWidth;\n            this.setPixelColor(i, rgb);\n        }\n\n        /**\n         * For NeoPixels with RGB+W LEDs, set the white LED brightness. This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"neopixel_set_pixel_white\" block=\"%strip|设置 pixel 白色 LED 在 %pixeloffset|到 %white\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        setPixelWhiteLED(pixeloffset: number, white: number): void {\n            if (this._mode === NeoPixelMode.RGBW) {\n                this.setPixelW(pixeloffset >> 0, white >> 0);\n            }\n        }\n\n        /**\n         * Send all the changes to the strip.\n         */\n        //% blockId=\"neopixel_show\" block=\"%strip|显示\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        show() {\n            // only supported in beta\n            // ws2812b.setBufferMode(this.pin, this._mode);\n            ws2812b.sendBuffer(this.buf, this.pin);\n        }\n\n        /**\n         * Turn off all LEDs.\n         * You need to call ``show`` to make the changes visible.\n         */\n        //% blockId=\"neopixel_clear\" block=\"%strip|清除\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        clear(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.fill(0, this.start * stride, this._length * stride);\n        }\n\n        /**\n         * Gets the number of pixels declared on the strip\n         */\n        //% blockId=\"neopixel_length\" block=\"%strip|长度\"\n        //% strip.defl=strip\n        //% weight=32\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        length() {\n            return this._length;\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 255\n         */\n        //% blockId=\"neopixel_set_brightness\" block=\"%strip|设置 亮度 %brightness\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        setBrightness(brightness: number): void {\n            this.brightness = brightness & 0xff;\n        }\n\n        /**\n         * Apply brightness to current colors using a quadratic easing function.\n         **/\n        //% blockId=\"neopixel_each_brightness\" block=\"%strip|清除 亮度\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        easeBrightness(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const br = this.brightness;\n            const buf = this.buf;\n            const end = this.start + this._length;\n            const mid = Math.idiv(this._length, 2);\n            for (let i = this.start; i < end; ++i) {\n                const k = i - this.start;\n                const ledoffset = i * stride;\n                const br = k > mid\n                    ? Math.idiv(255 * (this._length - 1 - k) * (this._length - 1 - k), (mid * mid))\n                    : Math.idiv(255 * k * k, (mid * mid));\n                const r = (buf[ledoffset + 0] * br) >> 8; buf[ledoffset + 0] = r;\n                const g = (buf[ledoffset + 1] * br) >> 8; buf[ledoffset + 1] = g;\n                const b = (buf[ledoffset + 2] * br) >> 8; buf[ledoffset + 2] = b;\n                if (stride == 4) {\n                    const w = (buf[ledoffset + 3] * br) >> 8; buf[ledoffset + 3] = w;\n                }\n            }\n        }\n\n        /**\n         * Create a range of LEDs.\n         * @param start offset in the LED strip to start the range\n         * @param length number of LEDs in the range. eg: 4\n         */\n        //% blockId=\"neopixel_range\" block=\"%strip|值域 从 %start|到 %length|leds\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% blockSetVariable=range\n        //% weight= 52\n        //% color=#2699BF blockGap=10\n        range(start: number, length: number): Strip {\n            start = start >> 0;\n            length = length >> 0;\n            let strip = new Strip();\n            strip.buf = this.buf;\n            strip.pin = this.pin;\n            strip.brightness = this.brightness;\n            strip.start = this.start + Math.clamp(0, this._length - 1, start);\n            strip._length = Math.clamp(0, this._length - (strip.start - this.start), length);\n            strip._matrixWidth = 0;\n            strip._mode = this._mode;\n            return strip;\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"neopixel_shift\" block=\"%strip|移动 pixels %offset\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        //% weight= 50\n        shift(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.shift(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Rotate LEDs forward.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to rotate forward, eg: 1\n         */\n        //% blockId=\"neopixel_rotate\" block=\"%strip|旋转 pixels %offset\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        //% weight= 50\n        rotate(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.rotate(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Set the pin where the neopixel is connected, defaults to P0.\n         */\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        setPin(pin: DigitalPin): void {\n            this.pin = pin;\n            pins.digitalWritePin(this.pin, 0);\n            // don't yield to avoid races on initialization\n        }\n\n        /**\n         * Estimates the electrical current (mA) consumed by the current light configuration.\n         */\n        //% blockId=neopixel_power block=\"%strip|电力 (mA)\"\n        //% strip.defl=strip\n        //% weight=32\n        //% advanced= true\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        power(): number {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const end = this.start + this._length;\n            let p = 0;\n            for (let i = this.start; i < end; ++i) {\n                const ledoffset = i * stride;\n                for (let j = 0; j < stride; ++j) {\n                    p += this.buf[i + j];\n                }\n            }\n            return Math.idiv(this.length() * 7, 10) /* 0.7mA per neopixel */\n                + Math.idiv(p * 480, 10000); /* rought approximation */\n        }\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            if (this._mode === NeoPixelMode.RGB_RGB) {\n                this.buf[offset + 0] = red;\n                this.buf[offset + 1] = green;\n            } else {\n                this.buf[offset + 0] = green;\n                this.buf[offset + 1] = red;\n            }\n            this.buf[offset + 2] = blue;\n        }\n\n        private setAllRGB(rgb: number) {\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            const br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            const end = this.start + this._length;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            for (let i = this.start; i < end; ++i) {\n                this.setBufferRGB(i * stride, red, green, blue)\n            }\n        }\n        private setAllW(white: number) {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            let end = this.start + this._length;\n            for (let i = this.start; i < end; ++i) {\n                let ledoffset = i * 4;\n                buf[ledoffset + 3] = white;\n            }\n        }\n        private setPixelRGB(pixeloffset: number, rgb: number): void {\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            let stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            pixeloffset = (pixeloffset + this.start) * stride;\n\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            let br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            this.setBufferRGB(pixeloffset, red, green, blue)\n        }\n        private setPixelW(pixeloffset: number, white: number): void {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this.start) * 4;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            buf[pixeloffset + 3] = white;\n        }\n    }\n\n    /**\n     * Create a new NeoPixel driver for `numleds` LEDs.\n     * @param pin the pin where the neopixel is connected.\n     * @param numleds number of leds in the strip, eg: 24,30,60,64\n     */\n    //% blockId=\"neopixel_create\" block=\"NeoPixel 在 端口 %pin|用 %numleds| leds 模式 %mode\"\n    //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n    //% trackArgs=0,2\n    //% blockSetVariable=strip\n    //% color=#2699BF blockGap=10\n    //% weight=51\n    export function create(pin: DigitalPin, numleds: number, mode: NeoPixelMode): Strip {\n        let strip = new Strip();\n        let stride = mode === NeoPixelMode.RGBW ? 4 : 3;\n        strip.buf = pins.createBuffer(numleds * stride);\n        strip.start = 0;\n        strip._length = numleds;\n        strip._mode = mode || NeoPixelMode.RGB;\n        strip._matrixWidth = 0;\n        strip.setBrightness(128)\n        strip.setPin(pin)\n        return strip;\n    }\n\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% blockId=\"neopixel_rgb\" block=\"红 %red|绿 %green|蓝 %blue\"\n    //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n    //% weight=32\n    //% color=#2699BF blockGap=10\n    export function rgb(red: number, green: number, blue: number): number {\n        return packRGB(red, green, blue);\n    }\n\n    /**\n     * Gets the RGB value of a known color\n    */\n    //% blockId=\"neopixel_colors\" block=\"%color\"\n    //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n    //% weight=32\n    //% color=#2699BF blockGap=10\n    export function colors(color: NeoPixelColors): number {\n        return color;\n    }\n\n    function packRGB(a: number, b: number, c: number): number {\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n    }\n\n    function unpackR(rgb: number): number {\n        let r = (rgb >> 16) & 0xFF;\n        return r;\n    }\n    \n    function unpackG(rgb: number): number {\n        let g = (rgb >> 8) & 0xFF;\n        return g;\n    }\n\n    function unpackB(rgb: number): number {\n        let b = (rgb) & 0xFF;\n        return b;\n    }\n\n    /**\n     * Converts a hue saturation luminosity value into a RGB color\n     * @param h hue from 0 to 360\n     * @param s saturation from 0 to 99\n     * @param l luminosity from 0 to 99\n     */\n    //% blockId=neopixelHSL block=\"色度 %h|饱和度 %s|亮度 %l\"\n    //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n    //% weight=32\n    //% color=#2699BF blockGap=10\n    export function hsl(h: number, s: number, l: number): number {\n        h = Math.round(h);\n        s = Math.round(s);\n        l = Math.round(l);\n\n        h = h % 360;\n        s = Math.clamp(0, 99, s);\n        l = Math.clamp(0, 99, l);\n        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\n        let h1 = Math.idiv(h, 60);//[0,6]\n        let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\n        let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\n        let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n        let r$: number;\n        let g$: number;\n        let b$: number;\n        if (h1 == 0) {\n            r$ = c; g$ = x; b$ = 0;\n        } else if (h1 == 1) {\n            r$ = x; g$ = c; b$ = 0;\n        } else if (h1 == 2) {\n            r$ = 0; g$ = c; b$ = x;\n        } else if (h1 == 3) {\n            r$ = 0; g$ = x; b$ = c;\n        } else if (h1 == 4) {\n            r$ = x; g$ = 0; b$ = c;\n        } else if (h1 == 5) {\n            r$ = c; g$ = 0; b$ = x;\n        }\n        let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\n        let r = r$ + m;\n        let g = g$ + m;\n        let b = b$ + m;\n        return packRGB(r, g, b);\n    }\n\n    export enum HueInterpolationDirection {\n        Clockwise,\n        CounterClockwise,\n        Shortest\n    }\n}\n","pxt.json":"{\n    \"name\": \"test3 extension\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"ws2812b\": \"github:microsoft/pxt-ws2812b#v0.1.1\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"4.0.11\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}